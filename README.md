# go-fuzz-utils
`go-fuzz-utils` is a helper package for use with [go-fuzz](https://github.com/dvyukov/go-fuzz) or other fuzzing utilities. `go-fuzz` provides a bare interface to fuzz, giving developers a randomly generated byte buffer to use in fuzzing campaigns. Although it's not difficult to convert this data into your desired variable types for tests, it often is often a tedious and ugly process to perform type conversions. 

`go-fuzz-utils` wraps a provided byte buffer such as `go-fuzz`'s test data and provides functions to read different value types from it, offering an interface to write cleaner tests.

## Construction
Simply ensure you have enough data to represent all the fuzz variables you wish to obtain, then construct a `TypeProvider`:
```go
	// Ensure the data is of appropriate length to read variables from
	if len(data) < 0x1000 {
		return
	}

	// Create our type provider
	tp := goFuzzUtils.NewTypeProvider(data)
```

## Simple data types
You can obtain the necessary type of data with exported functions such as:
```go
	// Obtain a byte from the buffer
	b, err := tp.GetByte()
...
	// Obtain an int16 from the buffer
	i16, err := tp.GetInt16()
...
	// Obtain a float32 from the buffer
	f32, err := tp.GetFloat32()
...
	// Obtain a fixed-length string from the buffer
	strFixed, err := tp.GetFixedString(7)
...
	// Obtain a dynamic-length string from the buffer
	strDynamic, err := tp.GetString(50) // maximum length of 50 
...
	// Obtain a fixed-length byte array from the buffer
	bytesFixed, err := tp.GetNBytes(2)
...
	// Obtain a dynamic-length byte array from the buffer
	bytesDynamic, err := tp.GetBytes(0) // maximum length 0 indicates we can read to the end of the buffer
```


## Complex data types
You can also populate simple data types, mappings, arrays, and arbitrary structures recursively via reflection.

For example, given the following structure:
```go
type testStruct struct {
	sArr []string
	bArr []byte
	stArr [] struct {
		s string
		i8 int8
		i16 int16
		i64 int64
		f64 float64
	}
	PublicString string
	PublicByte byte
}
```

You can simply perform a `Fill` call to populate it with the fuzz data:
```go
	// Create a test structure and fill it.
	st := testStruct{}
	err := tp.Fill(&st, 15, 20, 0, true) // strings of max length 15, arrays of max length 20, structs populated to 0 depth (infinite), and signal to fill private struct members.
```

Or with a complex type such as an array of mappings:
```go
	// Create an array of mappings and fill them.
	mappingArr := make([]map[string]int, 15)
	err = tp.Fill(&mappingArr, 15, 15, 0, true)
```
