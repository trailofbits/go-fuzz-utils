# go-fuzz-utils
`go-fuzz-utils` is a helper package for use with [go-fuzz](https://github.com/dvyukov/go-fuzz) or other fuzzing utilities. `go-fuzz` provides a bare interface to fuzz, giving developers a randomly generated byte buffer to use in fuzzing campaigns. Although it's not difficult to convert this data into your desired variable types for tests, it often is often a tedious and ugly process to perform type conversions. 

`go-fuzz-utils` wraps a provided byte buffer such as `go-fuzz`'s test data and provides functions to read different value types from it, offering an interface to write cleaner tests.

## Construction
Simply ensure you have enough data to represent all the fuzz variables you wish to obtain, then construct a `TypeProvider`:
```go
	// Ensure the data is of appropriate length to read variables from
	if len(data) < 0x1000 {
		return -1
	}

	// Create our type provider
	tp, err := go_fuzz_utils.NewTypeProvider(data)
    if err != nil {
        return -1
    }
```

## Simple data types
You can obtain the necessary type of data with exported functions such as:
```go
	// Obtain a byte from the buffer
	b, err := tp.GetByte()
...
	// Obtain an int16 from the buffer
	i16, err := tp.GetInt16()
...
	// Obtain a float32 from the buffer
	f32, err := tp.GetFloat32()
...
	// Obtain a fixed-length string from the buffer
	strFixed, err := tp.GetFixedString(7)
...
	// Obtain a dynamic-length string from the buffer
	strDynamic, err := tp.GetString(50) // maximum length of 50 
...
	// Obtain a fixed-length byte array from the buffer
	bytesFixed, err := tp.GetNBytes(2)
...
	// Obtain a dynamic-length byte array from the buffer
	bytesDynamic, err := tp.GetBytes(0) // maximum length 0 indicates we can read to the end of the buffer
```


## Complex data types
You can also populate simple data types, mappings, arrays, and arbitrary structures recursively via reflection.

For example, given the following structure:
```go
type testStruct struct {
	sArr []string
	bArr []byte
	stArr [] struct {
		s string
		i8 int8
		i16 int16
		i64 int64
		f64 float64
	}
	PublicString string
	PublicByte byte
}
```

You can simply perform a `Fill` call to populate it with the fuzz data:
```go
	// Create a test structure
	st := testStruct{}
    
    // Settings for the provided data (default values below)
	tp.SliceMinSize = 0
	tp.SliceMaxSize = 0
	tp.SliceNilBias = 0.05
	tp.MapMinSize = 0
	tp.MapMaxSize = 15
	tp.MapNilBias = 0.05
	tp.StringMinLength = 0
	tp.StringMaxLength = 15
	tp.DepthLimit = 0
	tp.FillUnexportedFields = true

	// Fill our structure
	err = tp.Fill(&st)
    
```

Or with a complex type such as an array of mappings:
```go
	// Create an array of mappings and fill them
	mappingArr := make([]map[string]int, 15)
	err = tp.Fill(&mappingArr)
```
